---
title: "From INDIVIDUAL to Episodes File"
author: "Göran Broström"
date: "`r Sys.Date()`"
output: 
   rmarkdown::html_vignette:
      toc: true
      depth: 3
      number_sections: true
vignette: >
  %\VignetteIndexEntry{From  INDIVIDUAL to Episodes File}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

# Introduction 

This is an example of how to go directly from an *INDIVIDUAL* file to an episodes file. We used a file from DDB, Umeå, covering the Skellefteå area ca 1800--1900. However, it turned out to be a not-so-good example, since it follows IDS Version 3, while we are working with Version 4. So, we go directly to the example data base created by [Luciana Quaranta](http://www.ekh.lu.se/personal/staff/ekh-lqn). It is included in this **R** package.



# Quaranta's Demo Data Base

To make it really simple, with no messy data, we use [Quaranta's demo data base](http://www.ehps-net.eu/article/stata-programs-using-intermediate-data-structure-ids-construct-files-statistical-analysis), which is included in this package as *external data* (an excel file). We convert the first sheet in the file to the **R** data frame *individual*.

```{r loaddemo, message=FALSE}
x <- system.file("extdata", "DemoDatabase.xlsx", mustWork = TRUE, package = "idsr")
library(readxl)
library(dplyr)
individual <- read_excel(x, sheet = 1)
names(individual)
```

It turns out that the variables *Start_day*, *Start_month*, *Start_year*, *End_day*, *End_month*, and *End_year* all contain only missing values (*NA*), so they can safely be removed.  

```{r, tabidd, Source}
with(individual, table(Id_D))
```

Obviously, we can get rid of the *Id_D* column as well:

```{r getrioof}
individual <- individual %>%
    select(Id_I, Type, Value, Value_Id_C, Day, Month, Year, Date_type, Source) %>%
    arrange(Id_I, Year, Month, Day)
knitr::kable(head(individual, 8))
```

This is all the information available for individual No. `r as.integer(individual$Id_I[1])`.

## Fix the dates

We fix the dates to a more useful format, the internal **R** *Date* format:

```{r fixdates}
individual$date <- 
    with(individual, as.Date(as.character(paste(Year, Month, Day, sep = "-")), 
                             format = "%Y-%m-%d"))
valid_date <- !is.na(individual$date)
Year_pos <- !is.na(individual$Year)
table(Year_pos, valid_date)
```

No problems with dates here, we can remove the variables *Year*, *Month*, and *Day*.

```{r cleanup}
individual <- select(individual, -Year, -Month, -Day) %>%
    arrange(Id_I, date, Type != "Start_observation", Type == "End_observation") 
knitr::kable(head(individual, 8))
```

Note that we reordered the rows so that in case of tied dates, *Start_observation* is always first and *End_observation* always last.

## Classifying covariates

There are three types of covariates: 

-   *observation*:Time-varying covariates, with change of level given by events. Example: *civil_status*, change of status by 
*marriage*, *death of partner*. (*Date_type == "Event" | Type %in% c("Start_observation", "End_observation")*.)
-   *obstime*: Time-varying covariates with no event expressing change of level. Example: *occupation*, 
observed only in connection with other events. (*Date_type == "Declared" & !is.na(date)*.)
-   *person*: Time-fixed covariates, known at entry. Example: *sex*, *birth date*. (*Date_type == "Declared" & is.na(date)*.)

We split the *INDIVIDUAL* frame into three pieces, *observation*, *obstime*, *person*, according to the above split.

### Separating out the time constant variables, *person*

```{r person}
person <- individual[individual$Date_type == "Declared" & is.na(individual$date), ]
person$date <- NULL
person$Date_type <- NULL
knitr::kable(head(person))
```

### Separating out the *obstime* frame

```{r}
obstime <- individual[individual$Date_type == "Declared" & 
                          !is.na(individual$date) & 
                          !(individual$Type %in% c("Start_observation", "End_observation")), ]
knitr::kable(head(obstime))
```

### Separating out the true time-varying covariates, *observation*

```{r}
observation <- individual[individual$Date_type == "Event" |
                              individual$Type %in% c("Start_observation", "End_observation"), ]
knitr::kable(head(observation))
```

# Creating an "Episodes frame" from *observation*



When creating an *episodes frame*, the *Date_type* *Event* is the basic building block. Events with associated *date* 
marks the *change of level* of a *covariate*. That is, each *Type* of Event must be tied to a covariate and its *state*.
For instance, The event *Marriage* is tied to the covariate *Civil_status* ant the level *married* 
(which is reached *after* the event).

Two "derived events", *Start_date* and *End_date* are not *marked* as *Event*, but should anyway 
be included among the other events: They mark the start and end dates of *presence periods* 
(one person can have several such periods), and is directly linked to Quaranta's *At_risk*  concept.
However, we prefer to call it *present*, because the statistical concept "at risk" is
not exactly the same thing as "present": It depends on the kind of phenomenon you are going to study.

```{r tabbla}
x <- with(observation, table(Type, Value))
knitr::kable(x)
```

So we have five types of events, and each type must be connected to a covariate. It should look like this:

|Event             | Covariate    | Level   | Mode     |
|------------------|--------------|---------|----------|
|Birth             | alive        | TRUE    | logical  |
|Death             | alive        | FALSE   | logical  |
|Marriage          | civil_status | married | factor   |
|Start_observation | present      | TRUE    | logical  |
|End_observation   | present      | FALSE   | logical  |

So, the generated covariates are *alive*, *civil_status*, and *present*.
We create a translation data frame:

```{r translate}
trans <- data.frame(Type = c("Birth", "Death", "Marriage", "Start_observation", "End_observation"),
                    Covariate = c("alive", "alive", "civil_status", "present", "present"),
                    Level = c("TRUE", "FALSE", "married", "TRUE", "FALSE"),
                    Mode = c("logical", "logical", "factor", "logical", "logical"),
                    stringsAsFactors = FALSE)
```


We create these new variables in the *observation* frame:

```{r newvar}
newvar <- c("alive", "civil_status", "present")
modes <- c("logical", "character", "logical")
n <- nrow(observation)
for (i in seq_along(newvar)){
    observation[[newvar[i]]] <- vector(mode = modes[i], length = n)
}
obs <- observation %>%
    select(-Value_Id_C, -Source)
knitr::kable(head(obs))
```

Now the values of *alive*, *civil_status*, and *present* must be filled in. *alive* and *present* start as *FALSE* and we let *civil_status* be *unmarried* until otherwise proven (*Type = Marriage*).

```{r fillup}
obs$civil_status <- "unmarried"
```

These "start values" are now "filled down" individually:

```{r filldownstart}
for (id in unique(obs$Id_I)){
    what <- which(obs$Id_I == id)
    ##cat(what, "\n")
    n <- length(what)
    ob <- obs[what, ]
    typ <- ob$Type[1]
    row <- which(trans$Type == typ)
    vari <- trans$Covariate[row]
    value <- trans$Level[row]
    ob[[vari]][1:n] <- value
    if (n > 1){
        for (i in 2:n){
            typ <- ob$Type[i]
            row <- which(trans$Type == typ)
            vari <- trans$Covariate[row]
            value <- trans$Level[row]
            ob[[vari]][i:n] <- value
        }
    }
    obs[what, ] <- ob
}
```




# Conclusion


Yet to be written ...

# References

Alter, George & Kees Mandemakers, 'The Intermediate Data Structure (IDS) for Longitudinal Historical Microdata, version 4', *Historical Life Course Studies* 1 (2014), 1--26.
[http](http://hdl.handle.net/10622/23526343-2014-0001?locatt=view:master)

Quaranta, Luciana, 'Using the Intermediate Data Structure (IDS) to Construct Files for Statistical Analysis', *Historical Life Course Studies* 2 (2015), 86--107.
[http](http://hdl.handle.net/10622/23526343-2015-0007?locatt=view:master)

Quaranta, Luciana, 'Stata Programs for Using the Intermediate Data Structure (IDS) to Construct files for Statistical Analysis', *Historical Life Course Studies* 3 (2015), 1--19. [http](http://hdl.handle.net/10622/23526343-2016-0001?locatt=view:master())
